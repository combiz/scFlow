---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  message = FALSE, 
  warning = FALSE
)
```
# scflow

<!-- badges: start -->
[![Travis build status](https://travis-ci.org/combiz/scflow.svg?branch=master)](https://travis-ci.org/combiz/scflow)
[![Codecov test coverage](https://codecov.io/gh/combiz/scflow/branch/master/graph/badge.svg)](https://codecov.io/gh/combiz/scflow?branch=master)
[![AppVeyor build status](https://ci.appveyor.com/api/projects/status/github/combiz/scflow?branch=master&svg=true)](https://ci.appveyor.com/project/combiz/scflow)
<!-- badges: end -->

The goal of scflow is to provide tools in R to build a complete analysis workflow for single-cell/nuclei RNA sequencing data.

* Quality control of gene-cell matrices
    - Filtering of matrices by counts and features
    - Filtering of mitochondrial genes and mitochondrial counts thresholding
    - Doublet and multiplet identification and removal with [DoubletFinder](https://github.com/chris-mcginnis-ucsf/DoubletFinder)
    - Rich QC metrics annotation with [scater](https://github.com/davismcc/scater)
  
* Dimensionality reduction and celltype identification
    - Louvain clustering, UMAP dimensionality reduction, and cluster marker gene identification with [monocle](https://github.com/cole-trapnell-lab/monocle-release)
    - Celltype annotation with [EWCE](https://github.com/NathanSkene/EWCE) and [Liger](https://github.com/MacoskoLab/liger)
    - Cluster identity mapping against the [Allen Human Brain Atlas](https://www.brain-map.org) and Mouse Nervous System Data from [Zeisel 2018](https://doi.org/10.1016/j.cell.2018.06.021)
  
* Differential gene expression implementations
    - Zero-inflated regression model with [MAST](https://github.com/RGLab/MAST)
    - Random effects model with [Limma](https://github.com/cran/limma)
    - Negative binomial distribution pseudobulking model with [DESeq2](https://github.com/mikelove/DESeq2)
    - Pseudobulk generalized likelihood ratio tests with [EdgeR](https://github.com/StoreyLab/edge)
  
* Pathway and functional category enrichment analysis
    - Interface to the Enrichr database with [EnrichR](https://github.com/cran/enrichR)
    - Interface to the WebGestalt tool with [WebGestaltR](http://www.webgestalt.org/)
 
* Publication quality plots and analysis reports
    - QC plots and tabular metrics suitable for reports.
    - UMAP plots for cell features and gene expression.
    - Violin plots for gene expression.
    - Pathway and gene enrichment plots
 
The package functions are designed to interface neatly with [NextFlow](https://www.nextflow.io/) for scalable and containerized pipelines deployed locally, on high-performance computing clusters, or in the cloud.  An accompanying NextFlow pipeline is in the works - TBA.


## Installation

You can install the development version of scflow from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("combiz/scflow")
```

## Developers

You may need to install scflow using a Personal Access Token (Github->Settings->Developer Settings): -

``` r
# install.packages("devtools")
devtools::install_github("combiz/scflow", auth_token = "YOURTOKEN")
```

## Running _scflow_
The basic `scflow` workflow for sample QC begins with the import of the feature-barcode sparse matrix with `read_sparse_matrix`.  The metadata for the sample is then imported from a sample sheet with `read_metadata`.  A SingleCellExperiment object is created from the matrix and the metadata using `generate_sce` which is then annotated with both gene and cell-level data using `annotate_sce`.  We then filter the SingleCellExperiment to select only cells and genes meeting our QC criteria using `filter_sce`.  We can then optionally find singlets in our filtered SingleCellExperiment using `find_singlets` before filtering them out again with `filter_sce`.  A complete QC report can then be generated using `report_qc_sce` before saving the filtered and quality-controlled SingleCellExperiment with `write_sce`.

### Step one - import the matrix and metadata

```{r eval=TRUE, results="hide", include=FALSE}
matrix_fp <- paste(system.file("extdata", package = "scflow"), "/", "individual_1", sep = "")
samplesheet_fp <- paste(system.file("extdata", package = "scflow"), "/", "SampleSheet.tsv", sep = "") 
ensembl_fp <- paste(system.file("extdata", package = "scflow"), "/", "ensembl_mappings.tsv", sep = "")
```

```{r eval=FALSE, results="hide"}
matrix_fp <- "path/to/matrix/file"
samplesheet_fp <- "path/to/SampleSheet.tsv"
ensembl_fp <- "path/to/ensembl_mapping_file.tsv"
```


```{r eval=TRUE, results="hide", message=FALSE, warning=FALSE}
library(scflow)
mat <- read_sparse_matrix(matrix_fp)
```

Next we retrieve the metadata by pointing to a Sample Sheet and specifying a unique identifier (unique_key) in a specific column (key_colname):

  ```{r eval=TRUE, message=TRUE}
metadata <- read_metadata(
  unique_key = "fonij",
  key_colname = "manifest",
  samplesheet_path = samplesheet_fp
)
```

For downstream analyses it’s important that the variable classes are correctly specified. Carefully inspect the metadata classes in brackets. In the above example we see that the _individual_ were imported as integer rather than factor variables. Let’s correct this by reloading the metadata, this time specifying the correct variable classes for this variable:-

  ```{r eval=FALSE, message=TRUE}
var_classes <- c(
  individual = "factor"
)

metadata <- read_metadata(
  unique_key = "lodut",
  key_colname = "manifest",
  samplesheet_path = samplesheet_fp,
  col_classes = var_classes
)
```

With the metadata imported with the correct variable classes, and the previously loaded sparse matrix, we can generate our `SingleCellExperiment` object:-

  ```{r eval=FALSE, results="hide"}
sce <- generate_sce(mat, metadata)
```

The SingleCellExperiment object was succesfully created and we can now proceed with annotation.

### Step two -- Annotate the SingleCellExperiment

In `scflow` we specify all of our QC preferences and cutoffs with the `annotate_sce` command.  This will also produce plots in the `sce@metadata` slot allowing rapid revision and optimization of QC parameters.  Let's start with the default parameters by simply providing the `SingleCellExperiment` object to the `annotate_sce` function:-


```{r eval=FALSE, message=TRUE}
sce <- annotate_sce(
  sce,
  ensembl_mapping_file = ensembl_fp
)
```

A list of QC plots are available to browse in the `sce@metadata$qc_plots`, e.g.

```{r eval=TRUE, include=FALSE, results="hide"}
sce <- readRDS(paste(system.file("extdata", package = "scflow"), "/", "sce.rds", sep = ""))
```


```{r eval=TRUE, message=TRUE}
sce@metadata$qc_plots$number_genes_vs_count_depth
```

After running `annotate_sce` we may examine the plots and assess whether the applied thresholds are sensible for the sample.  The effects of different parameters can be explored by iterating through the above `generate_sce` and `annotate_sce` functions until satisfied with the settings.

The next step is to filter the SingleCellExperiment with `filter_sce`: -

```{r eval=FALSE, message=TRUE}
sce <- filter_sce(sce)
```


### Step three -- Finding singlets and discarding multiplets

At this stage we may wish to identify singlets in the `SingleCellExperiment` and discard any multiplets.  In `scflow` we simply run `find_singlets` and specify our preferred multiplet identification algorithm.  Here we will use `doubletfinder` (This will take a while depending on the cell numbers):-

```{r eval=FALSE, results="hide"}
sce <- find_singlets(sce, "doubletfinder", pK = 0.005, vars_to_regress_out = c("nCount_RNA", "pc_mito"))
```

Now we can filter out these multiplets with `filter_sce`:-

```{r eval=FALSE, results="hide"}
sce <- filter_sce(sce)
```

You can see the remaining cells after all the filtering done by:

```{r eval=TRUE, message=TRUE}
dim(sce)
```

Finally we produce a report with `report_qc_sce` (this takes a few minutes): -

```{r eval=FALSE}
report_qc_sce(sce, report_file = "qc_report_scflow_individual_1")
```

And save our SingleCellExperiment: -
```{r eval=FALSE}
write_sce(sce, "./sce_individual_1")
```

### Step four -- Merging multiple datasets into one _SingleCellExperiment_ object

Follow step one-three for all individual samples and save them using `write_sce` function. Then we read the individual `SingleCellExperiment` using `read_sce` into a list and merge them using `merge_sce` function.

```{r eval=FALSE}
sce_path <- dir(
  path = "/path/to/dir",
  pattern = "sce_individual",
  full.names = TRUE
)

sce_pathlist <- list()

for (i in sce_path) {
  sce_pathlist[[i]] <- i
}

sce_list <- lapply(sce_pathlist, read_sce)

sce_merged <- merge_sce(
  sce_list,
  ensembl_mapping_file = ensembl_fp
)
```


Then we write the merged `SingleCellExperiment` object.

```{r eval=FALSE}
write_sce(
  sce = sce_merged,
  folder_path = "./sce_merged"
)
```


### Step five -- Dimension reduction and clustering

Once we merge all the samples into one `SingleCellExperiment` object we can move to the next steps of dimension reduction and clustering. Here dimension reduction is performed using multiple methods by default i.e. "PCA", "tSNE", "UMAP", "UMAP3D". Once the dimension reduction step is done the `SingleCellExperiment` object is ready for clustering.

```{r eval=TRUE, results="hide", include=FALSE}
sce_merged <- read_sce(
  paste(system.file("extdata", package = "scflow"), "/", "sce_merged", sep = "")
  )
```

```{r eval=TRUE, message=TRUE}
dim(sce_merged)
```

```{r eval=FALSE, results="hide"}
sce_merged <- reduce_dims_sce(sce_merged, pca_dims = 5)
```

We can now plot tSNE:-

```{r eval=TRUE, message=TRUE}
plot_umap_with_feature(sce_merged, feature_dim = "diagnosis", reduced_dim = "tSNE", alpha = 1)
```

The next step is to cluster all the cells using `cluster_sce` command.

```{r eval=FALSE, results="hide"}
sce_merged <- cluster_sce(sce_merged)
```

We can then plot the clusters:-

```{r eval=TRUE, message=TRUE}
plot_umap_with_feature(sce_merged, feature_dim = "clusters", reduced_dim = "tSNE", alpha = 1)
```

The next step is to annotate the celltypes for each cluster. Here, we will use the package `ewce`. For this we use the following command (This may take a while):-

```{r eval=FALSE, results="hide"}
sce_merged <- map_celltypes_sce(sce_merged,
  ctd_folder = paste(system.file("extdata", package = "scflow"), "/", "ctd", sep = "")
)
```

The celltypes for each cell can be found in `sce_merged@colData$cluster_celltype` slot. We can also generate tSNE plot for each celltype.

```{r eval=TRUE, message=TRUE}
plot_umap_with_feature(sce_merged, feature_dim = "cluster_celltype", reduced_dim = "tSNE", alpha = 1)
```


###Performing differential expression analysis following by impacted pathway analysis

We need to subset the merged `SingleCellExperiment` object to perform differential expression analysis. Here we are using `MASTZLM` for differential expression analysis. For example, we are interested in performing DE analysis in the `IN-SST` cell cluster. So, we first subset the `IN-SST` cluster.

```{r eval=FALSE}
sce_subset <- sce_merged[, sce_merged$cluster_celltype == "IN-SST"]
```

We need to specify the colData column name as dependent_var as the variable of interest for DE analysis. For example here we want to perform DE analysis between Case and Controls which is found in `diagnosis` column. ref_class is the reference group for DE analysis. If there are any confounding variables those colData names can be passed through confounding_vars argument.

```{r eval=FALSE, results="hide"}
result_de <- perform_de(
  sce_subset,
  dependent_var = "diagnosis",
  ref_class = "Controls",
  confounding_vars = c("cngeneson", "sex"),
  ensembl_mapping_file = ensembl_fp)
```

```{r eval=TRUE, results="hide", include=FALSE}
result_de <- readRDS(
  paste(system.file("extdata", package = "scflow"), "/", "result_de.rds", sep = "")
  )
```

result_de is a list of DE tables. If there are more than one group to be compared against the reference (here `Controls`) group they will all be merged into the `result_de@Controls_Merged_Results` slot.


```{r eval=TRUE, message=TRUE}
head(result_de$Controls_vs_diagnosisCases, 5)
```


We have implimented both topology based and non-topology based pathway enrichment analysis. Here we will use ROntoTools and WebGestaltR respectively. 

```{r eval=FALSE}
enrichment_result_webgestaltr <- pathway_analysis_webgestalt(
  gene_file = result_de$Controls_vs_diagnosisCases,
  enrichment_method = "ORA",
  project_name = TRUE,
  additional_enrichment_databse = FALSE,
  is_output = FALSE,
  output_dir = "~/"
)
```

```{r eval=TRUE, include=FALSE, results="hide"}
enrichment_result_webgestaltr <- readRDS(
  paste(system.file("extdata", package = "scflow"), "/", "res_webgestaltr.rds", sep = ""))

enrichment_result_rontotools <- readRDS(
  paste(system.file("extdata", package = "scflow"), "/", "res_rontotools.rds", sep = ""))
```

```{r eval=TRUE, message=TRUE}
enrichment_result_webgestaltr$pathway_KEGG[1:5, c(1,2,8,9)]

enrichment_result_webgestaltr$plot$pathway_KEGG
```


```{r eval=FALSE}
set.seed(1234)
enrichment_result_rontotools <- pathway_analysis_rontotools(
  gene_file = result_de$Controls_vs_diagnosisCases,
  project_name = TRUE,
  enrichment_database = c("kegg", "reactome", "nci", "panther"),
  is_output = TRUE,
  output_dir = "~/"
)
```

```{r eval=TRUE, message=TRUE}
enrichment_result_rontotools$kegg[1:5, c(1,2,6,7)]

enrichment_result_rontotools$plot$kegg
```

